{
    "model": "my-coder",
    "created_at": "2026-02-06T23:18:25.958004831Z",
    "message": {
        "role": "assistant",
        "content": "Certainly! Below is a Go implementation of a thread-safe LRU (Least Recently Used) cache using the `sync.Mutex` for synchronization. The cache includes `Get` and `Put` methods, along with proper error handling.\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"sync\"\n)\n\n// LRUCache represents an LRU cache.\ntype LRUCache struct {\n\tcapacity int\n\tcache    map[int]*Node\n\thead     *Node\n\ttail     *Node\n\tmu       sync.Mutex\n}\n\n// Node represents a node in the doubly linked list.\ntype Node struct {\n\tkey   int\n\tvalue interface{}\n\tprev  *Node\n\tnext  *Node\n}\n\n// NewLRUCache creates a new LRU cache with the given capacity.\nfunc NewLRUCache(capacity int) (*LRUCache, error) {\n\tif capacity <= 0 {\n\t\treturn nil, errors.New(\"capacity must be greater than zero\")\n\t}\n\treturn &LRUCache{\n\t\tcapacity: capacity,\n\t\tcache:    make(map[int]*Node),\n\t}, nil\n}\n\n// Get retrieves the value for a given key. If the key is not found, it returns an error.\nfunc (c *LRUCache) Get(key int) (interface{}, error) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tnode, ok := c.cache[key]\n\tif !ok {\n\t\treturn nil, errors.New(\"key not found\")\n\t}\n\n\t// Move the node to the front of the list\n\tc.moveToFront(node)\n\treturn node.value, nil\n}\n\n// Put inserts a new key-value pair into the cache. If the key already exists, it updates the value.\nfunc (c *LRUCache) Put(key int, value interface{}) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif node, ok := c.cache[key]; ok {\n\t\t// Update the existing node\n\t\tnode.value = value\n\t\tc.moveToFront(node)\n\t\treturn nil\n\t}\n\n\t// Create a new node and add it to the front of the list\n\tnewNode := &Node{key: key, value: value}\n\tc.cache[key] = newNode\n\n\tif c.head == nil {\n\t\tc.head = newNode\n\t\tc.tail = newNode\n\t} else {\n\t\tnewNode.next = c.head\n\t\tc.head.prev = newNode\n\t\tc.head = newNode\n\t}\n\n\t// If the cache exceeds capacity, remove the least recently used item (tail)\n\tif len(c.cache) > c.capacity {\n\t\tdelete(c.cache, c.tail.key)\n\t\tc.tail = c.tail.prev\n\t\tif c.tail != nil {\n\t\t\tc.tail.next = nil\n\t\t} else {\n\t\t\tc.head = nil\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// moveToFront moves a node to the front of the doubly linked list.\nfunc (c *LRUCache) moveToFront(node *Node) {\n\tif node == c.head {\n\t\treturn\n\t}\n\n\tif node.prev != nil {\n\t\tnode.prev.next = node.next\n\t}\n\tif node.next != nil {\n\t\tnode.next.prev = node.prev\n\t}\n\n\tif node == c.tail {\n\t\tc.tail = node.prev\n\t}\n\n\tnode.prev = nil\n\tnode.next = c.head\n\tc.head.prev = node\n\tc.head = node\n}\n\nfunc main() {\n\tcache, err := NewLRUCache(2)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = cache.Put(1, \"one\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tval, err := cache.Get(1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tprintln(val.(string)) // Output: one\n\n\terr = cache.Put(2, \"two\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tval, err = cache.Get(1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tprintln(val.(string)) // Output: one\n\n\terr = cache.Put(3, \"three\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tval, err = cache.Get(2)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tprintln(val.(string)) // Output: two\n}\n```\n\n### Explanation:\n\n1. **LRUCache Structure**:\n   - `capacity`: The maximum number of items the cache can hold.\n   - `cache`: A map to store key-value pairs.\n   - `head` and `tail`: Pointers to the head and tail of the doubly linked list, which helps in maintaining the order of usage (most recently used at the front).\n   - `mu`: A mutex for thread-safe operations.\n\n2. **Node Structure**:\n   - Represents a node in the doubly linked list.\n   - Contains the key, value, previous, and next pointers.\n\n3. **NewLRUCache Function**:\n   - Creates a new LRU cache with the given capacity.\n   - Validates the capacity to be greater than zero.\n\n4. **Get Method**:\n   - Retrieves the value for a given key.\n   - If the key is not found, it returns an error.\n   - Moves the accessed node to the front of the list to mark it as recently used.\n\n5. **Put Method**:\n   - Inserts a new key-value pair into the cache.\n   - If the key already exists, it updates the value and moves the node to the front.\n   - If the cache exceeds its capacity, it removes the least recently used item (the tail of the list).\n\n6. **moveToFront Method**:\n   - Moves a node to the front of the doubly linked list.\n\n7. **main Function**:\n   - Demonstrates the usage of the LRU cache with some example operations.\n\nThis implementation ensures that the cache is thread-safe and follows the LRU eviction policy efficiently."
    },
    "done": true,
    "done_reason": "stop",
    "total_duration": 20560362405,
    "load_duration": 65910250,
    "prompt_eval_count": 104,
    "prompt_eval_duration": 362162476,
    "eval_count": 1191,
    "eval_duration": 18862699439
}
